// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
// vi: set ts=2 noet:
//
// (c) Copyright Rosetta Commons Member Institutions.
// (c) This file is part of the Rosetta software suite and is made available under license.
// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.

/*!

@page robust How to make mini robust against malformed PDBs

@author Steven Lewis smlewi@gmail.com

This document was orginally written 6 Apr 2010 by Steven Lewis.  This document was last updated 26 May 2011 by Steven Lewis.

@section purpose What is robust?
Rosetta's PDB reader is fragile, and the PDB is not particularly carefully curated.  There are lots of PDBs that cannot be read in by Rosetta (several thousand fail to read in at all), and many more that cannot be scored for some reason.  Unfortunately, these bad PDBs tend to cause Rosetta to crash rather than exit gracefully.  This document describes how to "robustify" Rosetta so that it will not crash when encountering a bad PDB.

@section when When would I use it?
You might want to robustify Rosetta if you are going to do a small-nstruct, large -l experiment.  In my case, I ran with -nstruct 1 against literally the entire PDB.

@section why_not Why are these not set up by default?
The changes that have to be made cause a significant performance hit to Rosetta (particularly the vectorL change).  These should not be left on by default.  A better question is, why does no one improve the PDB reader to more gracefully catch these errors.  The answer to that is: why don't you do it, and make this page obsolete?

@section how Okay, I'm convinced, how do I do it?
You NEED to make a few changes:

@li run your code under jd2
@li replace all assert() statements in utility/vectorL with runtime_assert statements.  This causes out-of-bounds errors in the Rosetta workhorse vector1 class to be caught in the assert instead of segfaulting.  You could also compile in debug mode, or leave the NDEBUG statements in release mode.  The point is that bounds checking must be on.  (This is what causes the performance hit)
@li replace all assert()s in the Conformation class with runtime_assert, or equivalent.
@li ensure that the preprocessor statement EXIT_THROWS_EXCEPTION is defined.  You can do this on command line, or modify user.settings.  For example, modify user.settings to include: "appends" : { "defines" : ["EXIT_THROWS_EXCEPTION"], },

This combination of changes will cause vector overruns to throw exceptions inside runtime_assert, instead of crashing or causing segfaults.  jd2 will catch the exceptions and treat the failed PDB as a failed job, print an error message, and cleanly move on to the next PDB in your list.

There are some other suggested changes:
@li pass the @verbatim -in:file:obey_ENDMDL @endverbatim flag.  This causes the PDB reader to stop reading multimodel NMR-derived PDBs after the first model.
@li pass the @verbatim -jd2:delete_old_poses @endverbatim flag.  This causes JD2 to not leak memory by holding on to old input poses.

*/

#!/usr/bin/env python
#
# (c) Copyright Rosetta Commons Member Institutions.
# (c) This file is part of the Rosetta software suite and is made available under license.
# (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
# (c) For more information, see http://www.rosettacommons.org. Questions about this can be
# (c) addressed to University of Washington CoMotion, email: license@uw.edu.

"""File: src/core/chemical/residue_properties/update_ResidueType_enum_files.py

Brief: This PyRosetta script auto-generates C++ code used by the
ResidueProperties system.

Details: To add a new property or variant type to Rosetta for use in .params
files, patch files, and ResidueTypes, simply add a string to the
general_properties.list or variant_types.list files, respectively, and run
this script.

(You may also consider adding new is_ accessors to ResidueType and Residue.)

Example: ./update_ResidueType_enum_files.py

Author: Jason W. Labonte

Author: Vikram K. Mulligan -- updated for thread-safety.

"""

# Imports
from __future__ import with_statement, print_function
from os.path import isfile


# Constants
HEADER = [
    '// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;'
                                                   'rm-trailing-spaces:t -*-\n',
    '// vi: set ts=2 noet:\n',
    '//\n',
    '// (c) Copyright Rosetta Commons Member Institutions.\n',
    '// (c) This file is part of the Rosetta software suite and is made '
                                                   'available under license.\n',
    '// (c) The Rosetta software is developed by the contributing members of '
                                                       'the Rosetta Commons.\n',
    '// (c) For more information, see http://www.rosettacommons.org. Questions '
                                                          'about this can be\n',
    '// (c) addressed to University of Washington UW CoMotion, email: '
                                                  'license@uw.edu.\n',
    "\n"]
AUTHOR_AND_NOTE = [
    '/// @author  Labonte <JWLabonte@jhu.edu>\n',
    '/// @author  Vikram K. Mulligan (vmullig@uw.edu) -- updated for multi-threading\n',
    '/// @note    DO NOT EDIT THIS FILE DIRECTLY!  It is auto-generated.\n',
    '/// If you wish to edit it, modify the update_ResidueType_enum_files.py '
                                                                    'script.\n']
NAMESPACE_OPENING = [
    'namespace core {\n',
    'namespace chemical {\n',
    "\n"]
NAMESPACE_CLOSING = [
    '}  // namespace chemical\n',
    '}  // namespace core\n']


class EnumInfo:
    """A structure for containing information about each kind of enum:
    its name in the code, the input file for its definitions data, Doxygen info,
    etc.

    """
    def __init__(self, enum_name):
        self.name = enum_name  # this enum's name in the code (in CamelCase)
        self.short_name = ""
        self.short_name_plural = ""
        self.input_file = ""  # the input file from which this enum is defined
        self.header_file = self.name + '.hh'
        self.source_file = self.name + '_mappings.cc'
        self.brief = ""  # Doxygen brief for this enum
        self.details = []  # Doxygen details for this enum


def read_lines_from_file(filename):
    """Return each line of a file to a list."""
    lines = []
    with open(filename) as f:
        for line in f:
            if not line.startswith("#") and line != "\n":
                lines.append(line)
    return lines


def separate_definitions_from_comments(lines_to_parse):
    """Parse each line by searching for a # symbol and return two lists."""
    definitions = []
    comments = []
    already_used_definitions = []

    for line in lines_to_parse:
        split_data = line.split("#")
        definition = split_data[0].strip()

        # Check for duplicated definitions.
        if definition in already_used_definitions:
            print('WARNING: The enum definition', definition, 'is found in',)
            print('the list twice!  Ignoring...')
            continue
        already_used_definitions.append(definition)

        comment = ''
        if len(split_data) > 1:
            comment = split_data[1].rstrip()

        definitions.append(definition)
        comments.append(comment)
    return definitions, comments


def write_lines_to_file_if_necessary(lines, filename):
    """Compare the existing file with the proposed new file and only write the
    new file with different.

    Return True if a new file has been written.

    """
    if isfile('../' + filename):
        with open('../' + filename, "r") as f:
            existing_lines = f.readlines()
        if lines == existing_lines:
            return False

    with open('../' + filename, "w") as f:
        f.writelines(lines)
    print('Successfully generated ' + filename + ".")
    return True


def Doxygen_info(filename, brief, additional_note=""):
    """Return the lines of Doxygen info, given the filename and description."""
    lines = []
    lines.append('/// @file    core/chemical/' + filename + "\n")
    lines.append('/// @brief   ' + brief + "\n")
    lines.extend(AUTHOR_AND_NOTE)
    if additional_note:
        lines.append('/// ' + additional_note + "\n")
    lines.append("\n")
    return lines


def do_not_edit_warning(short_name, filename):
    """Return lines providing a 'do not edit' comment warning."""
    lines = []
    lines.append('// If adding a new ' + short_name +
                         ', DO NOT MANUALLY EDIT THIS ENUMERATOR DEFINITION.\n')
    lines.append('// Instead, add it to ' + filename +
                     ', and run the update_ResidueType_enum_files.py script.\n')

    return lines


def generate_enum_header_file(enum_info, enum_defs, comments):
    """Write a header file from lists of enum definitions and their
    corresponding comments, if the data have changed.

    Return True if a new file has been written.

    """
    lines = []

    # Add the header.
    lines.extend(HEADER)

    # Add the Doxygen info.
    lines.extend(Doxygen_info(enum_info.header_file,
                          'Enumeration definition for ' + enum_info.name + "."))

    # Add the header guard.
    lines.append('#ifndef INCLUDED_core_chemical_' + enum_info.name + '_HH\n')
    lines.append('#define INCLUDED_core_chemical_' + enum_info.name + '_HH\n')
    lines.append("\n")

    # Add the namespacing.
    lines.extend(NAMESPACE_OPENING)

    # Add the comments and the enum declaration.
    lines.extend(do_not_edit_warning(enum_info.short_name,
                                     enum_info.input_file))
    lines.append('/// @brief   ' + enum_info.brief + "\n")
    if enum_info.details:
        enum_info.details[0] = '/// @details ' + enum_info.details[0] + "\n"
        for i in range(1, len(enum_info.details)):
            enum_info.details[i] = '/// ' + enum_info.details[i] + "\n"
        lines.extend(enum_info.details)
    lines.append('enum ' + enum_info.name + ' {\n')

    # Define the enumeration values.
    first_def = '\tNO_'
    first_def += enum_info.short_name.upper()
    first_def += ' = 0,\n'
    lines.append(first_def)

    first_def = '\tFIRST_'
    first_def += enum_info.short_name.upper()
    first_def += ' = 1,\n'
    lines.append(first_def)

    for enum_def, comment in zip(enum_defs, comments):
        line = "\t" + enum_def
        if enum_def != enum_defs[0]:  # if not the 1st definition...
            line += ","
        else:
            line += ' = 1,'
        if comment:
            line += '  //' + comment
        line += "\n"
        lines.append(line)

    # Include an enum value for the total number of values.
    last_def = '\tN_'
    last_def += enum_info.short_name_plural.upper()
    last_def += ' = '
    last_def += enum_defs[-1]
    last_def += "\n"
    lines.append(last_def)
    lines.append('};\n')
    lines.append("\n")

    # Close the namespacing and header guard.
    lines.extend(NAMESPACE_CLOSING)
    lines.append("\n")
    lines.append('#endif  // INCLUDED_core_chemical_' + enum_info.name +
                                                                        '_HH\n')

    return write_lines_to_file_if_necessary(lines, enum_info.header_file)


def generate_mappings_source_file(enum_info, enum_defs):
    """Write the _mappings.cc file from a list of enum values, if the
    data have changed.

    Return True if a new file has been written.

    """
    lines = []

    # Add the header.
    lines.extend(HEADER)

    # Add the Doxygen info.
    lines.extend(Doxygen_info(enum_info.source_file,
                              'Method definitions for private static methods '
                                      'declared in ResidueProperties.hh.',
                              'It is because it is auto-generated that these '
                                      'class methods are not defined in '
                                      'ResidueProperties.cc.'))

    # Add the #includes.
    lines.append('// Unit header\n')
    lines.append('#include <core/chemical/ResidueProperties.hh>\n')
    lines.append("\n")
    lines.append('// Utility header\n')
    lines.append('#include <utility/vector1.hh>\n')
    lines.append('#include <utility/excn/Exceptions.hh>\n')
    lines.append("\n")
    lines.append('// C++ headers\n')
    lines.append('#include <map>\n')
    lines.append("\n")

    # Add the namespacing.
    lines.extend(NAMESPACE_OPENING)

    # Add "using namespace".
    lines.append('using namespace core;\n')
    lines.append('\n')

    # Add the generating function for the global map of string->enum.
    lines.append('std::map< std::string, ' + enum_info.name + ' > const *\n')
    lines.append('ResidueProperties::generate_string_to_' + enum_info.short_name + '_map() {\n' )

    lines.append('\t// A map of ' + enum_info.name +
        ' enum values keyed by corresponding string.\n')
    lines.append('\tstd::map< std::string, ' + enum_info.name + ' > * output_map( new std::map< std::string, ' + enum_info.name + ' > );\n')
    if ( enum_info.short_name == "variant" ):
         # quick hack -- could probably do this for PROPERTY also -- rhiju
        lines.append( '\toutput_map->insert( std::make_pair( "NO_VARIANT", NO_VARIANT ) );\n' )
    for enum_def in enum_defs:
        line = '\toutput_map->insert( std::make_pair( "'
        line += enum_def + '", ' + enum_def + ' ) );\n'
        lines.append(line)
    lines.append('\n')
    lines.append('\treturn output_map;\n')
    lines.append('}\n')
    lines.append('\n')

    # Add declaration of global map of string->enum.
    map_name = enum_info.short_name.upper() + '_MAP'
    lines.append('static const std::map< std::string, ' + enum_info.name + ' > * const ' +
                                                        map_name + '( ResidueProperties::generate_string_to_' + enum_info.short_name + '_map() );\n')
    lines.append('\n')




    # Add the first method -- from string to enum value.
    # Add the comments and function signature.
    lines.append('// Get the ' + enum_info.name +
                                  ' enum value from the corresponding sting.\n')
    lines.append('// This private static class method is declared in '
                                                      'ResidueProperties.hh.\n')
    lines.extend(do_not_edit_warning(enum_info.short_name,
                                     enum_info.input_file))
    lines.append(enum_info.name + ' const &\n')
    lines.append('ResidueProperties::get_' + enum_info.short_name +
           '_from_string( std::string const & ' + enum_info.short_name + ' )\n')

    # Define the function.
    lines.append('{\n')
    lines.append('\tusing namespace std;\n')
    lines.append('\tusing namespace utility::excn;\n')
    lines.append('\n')
    lines.append('\t// The map of string->enum has been generated once in a threadsafe manner, since it is static const data.\n')
    lines.append('\t// As such, we do not need to worry about locking mutexes or any of that nonsense.\n')

    lines.append("\n")
    lines.append('\tif ( ! ( *' + map_name + ' ).count( ' +
                                              enum_info.short_name + ' ) ) {\n')
    if ( enum_info.short_name == "variant" ):
         # quick hack -- could probably do this for PROPERTY also -- rhiju
        lines.append('\t\treturn ( *VARIANT_MAP ).at( "NO_VARIANT" );\n')
    else:
        lines.append('\t\tthrow CREATE_EXCEPTION(Exception, "Rosetta does not recognize '
                     'the ' + enum_info.short_name + ': " + ' +
                     enum_info.short_name + ' +\n')
        lines.append('\t\t\t\t"; has it been added to ' + enum_info.input_file +
                                                                      '?" );\n')
    lines.append('\t}\n')
    lines.append("\n")
    lines.append('\treturn ( *' + map_name + ' ).at( ' + enum_info.short_name +
                                                                        ' );\n')
    lines.append('}\n')
    lines.append("\n")


    # Add initialization function for second method (from enum value to string).
    # Add the generating function for the global map of string->enum.
    lines.append('utility::vector1< std::string > const *\n')
    lines.append('ResidueProperties::generate_' + enum_info.short_name + '_to_string_vector() {\n' )

    lines.append('\t// A vector of strings keyed by ' + enum_info.name +
                '.\n')
    lines.append('\tutility::vector1 < std::string > * output_vect( new utility::vector1< std::string > );\n')
    lines.append('\toutput_vect->resize( N_' +
                  enum_info.short_name_plural.upper() + ', "" );\n')
    lines.append('\n')

    for enum_def in enum_defs:
        line = '\t( *output_vect )[ '
        line += enum_def + ' ] = "' + enum_def + '";\n'
        lines.append(line)
    lines.append('\n')
    lines.append('\treturn output_vect;\n')
    lines.append('}\n')
    lines.append('\n')

    # Define the static const global data.
    lines.append('static const utility::vector1< std::string > * const STRING_LIST( ResidueProperties::generate_' + enum_info.short_name + '_to_string_vector() );\n')
    lines.append('\n')


    # Add the second method -- from enum_value to string.
    # Add the comments and function signature.
    lines.append('// Get a string from the corresponding ' + enum_info.name +
                                                               ' enum value.\n')
    lines.append('// This private static class method is declared in '
                                                      'ResidueProperties.hh.\n')
    lines.extend(do_not_edit_warning(enum_info.short_name,
                                     enum_info.input_file))
    lines.append('std::string const &\n')
    lines.append('ResidueProperties::get_string_from_' + enum_info.short_name +
                         '( ' + enum_info.name + ' const ' +
                         enum_info.short_name + ' )\n')

    # Define the function.
    lines.append('{\n')
    lines.append('\treturn ( *STRING_LIST )[ ' + enum_info.short_name + ' ];\n')
    lines.append('}\n')
    lines.append("\n")

    # Close the namespacing.
    lines.extend(NAMESPACE_CLOSING)

    return write_lines_to_file_if_necessary(lines, enum_info.source_file)


def generate_files(enum_info):
    enum_data = read_lines_from_file(enum_info.input_file)
    enum_defs, comments = separate_definitions_from_comments(enum_data)

    enum_updated = generate_enum_header_file(enum_info, enum_defs, comments)
    mappings_updated = generate_mappings_source_file(enum_info, enum_defs)

    print('Finished updating', enum_info.name, 'code',)
    if not enum_updated and not mappings_updated:
        print('-- no changes needed')


# Main
properties = EnumInfo('ResidueProperty')
properties.short_name = 'property'
properties.short_name_plural = 'properties'
properties.input_file = 'general_properties.list'
properties.brief = 'Enumerators for all the properties that can be assigned ' \
                                                             'to a ResidueType.'

variants = EnumInfo('VariantType')
variants.short_name = 'variant'
variants.short_name_plural = 'variants'
variants.input_file = 'variant_types.list'
variants.brief = 'Enumerators for all the ResidueType variants.'
variants.details.append('VariantTypes are primarily utilized by the patch '
                              'system.  All the type does is add an identifier')
variants.details.append('that can be used later on in different protocols.  '
              'It also helps the patch system keep track of which residues are')
variants.details.append('patched with which patches.')

generate_files(properties)
generate_files(variants)

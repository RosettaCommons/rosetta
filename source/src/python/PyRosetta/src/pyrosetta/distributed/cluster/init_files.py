# :noTabs=true:
# (c) Copyright Rosetta Commons Member Institutions.
# (c) This file is part of the Rosetta software suite and is made available under license.
# (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
# (c) For more information, see http://www.rosettacommons.org. Questions about this can be
# (c) addressed to University of Washington CoMotion, email: license@uw.edu.


__author__ = "Jason C. Klima"


import json
import hmac
import os
import pyrosetta
import pyrosetta.distributed.io as io

from pyrosetta.distributed.packed_pose.core import PackedPose
from pyrosetta.rosetta.basic import was_init_called
from typing import Any, Dict, Generic, List, Optional, Tuple, TypeVar

from pyrosetta.distributed.cluster.hkdf import HASHMOD, compare_digest, derive_init_key


G = TypeVar("G")


class InitFileSigner(Generic[G]):
    """Sign PyRosetta initialization files by PyRosettaCluster."""

    _encoding = "utf-8"
    _prefix = b'PyRosettaCluster_init_file_signer'

    def __init__(self, input_packed_pose=None, output_packed_pose=None, metadata=None) -> None:
        self.inp_pkl = self._to_pickle(input_packed_pose)
        self.out_pkl = self._to_pickle(output_packed_pose)
        self.metadata_pkl = self._to_encoding(metadata)

    def _to_pickle(self, packed_pose: Optional[PackedPose]) -> bytes:
        return io.to_pickle(packed_pose) if isinstance(packed_pose, PackedPose) else b'\x00'

    def _to_encoding(self, obj: Any) -> bytes:
        return json.dumps(obj).encode(InitFileSigner._encoding)

    def _get_pose_digest(self, pkl: bytes) -> bytes:
        return HASHMOD(pkl).digest()

    def _join_bytes(self, *values: List[bytes]) -> bytes:
        return b'+'.join(values)

    def _setup_poses_pair(self, inp_pkl: bytes, out_pkl: bytes) -> bytes:
        return self._join_bytes(InitFileSigner._prefix, inp_pkl, out_pkl)

    def _get_poses_digest(self, inp_pkl: bytes, out_pkl: bytes) -> bytes:
        return HASHMOD(self._setup_poses_pair(inp_pkl, out_pkl)).digest()

    def _get_poses_hexdigest(self, inp_pkl: bytes, out_pkl: bytes) -> str:
        return HASHMOD(self._setup_poses_pair(inp_pkl, out_pkl)).hexdigest()

    def _get_pkg_data(self) -> bytes:
        return self._join_bytes(
            InitFileSigner._prefix,
            pyrosetta._version_string().encode(InitFileSigner._encoding),
            pyrosetta.distributed.cluster.__version__.encode(InitFileSigner._encoding),
        )

    def _get_hmac_hexdigest(self, key: bytes, data: bytes) -> str:
        return hmac.new(key, data, HASHMOD).hexdigest()

    def _get_init_key_and_msg(self) -> Tuple[bytes, bytes]:
        inp_digest = self._get_pose_digest(self.inp_pkl)
        out_digest = self._get_pose_digest(self.out_pkl)
        poses_digest = self._get_poses_digest(self.inp_pkl, self.out_pkl)
        pkg_data = self._join_bytes(self._get_pkg_data(), self.metadata_pkl, poses_digest)
        init_key = derive_init_key(b'InitFileSigner', pkg_data)
        msg = self._join_bytes(InitFileSigner._prefix, inp_digest, out_digest, pkg_data)

        return init_key, msg

    def sign_sha256(self) -> str:
        return self._get_poses_hexdigest(self.inp_pkl, self.out_pkl)

    def sign_digest(self) -> str:
        return self._get_hmac_hexdigest(*self._get_init_key_and_msg())

    def sign(self) -> Dict[str, str]:
        return {
            "sha256": self.sign_sha256(),
            "signature": self.sign_digest(),
        }

    def verify_sha256(self, sha256: str) -> bool:
        return sha256 == self._get_poses_hexdigest(self.inp_pkl, self.out_pkl)

    def verify_signature(self, signature: str) -> bool:
        return compare_digest(signature, self.sign_digest())

    def verify(self, sha256: str, signature: str) -> bool:
        return self.verify_sha256(sha256) and self.verify_signature(signature)


def setup_init_file_metadata_and_poses(
    input_packed_pose: Optional[PackedPose] = None,
    output_packed_pose: Optional[PackedPose] = None,
) -> Tuple[Dict[str, Any], List[PackedPose]]:
    """Setup PyRosetta initialization file 'metadata' and 'poses' keys."""

    metadata = {}
    metadata["comment"] = "Generated by PyRosettaCluster"
    metadata["version"] = pyrosetta.distributed.cluster.__version__
    poses = []
    if isinstance(output_packed_pose, PackedPose): # Set output decoy to front of poses list if present
        poses.append(output_packed_pose)
        metadata["idx_output"] = poses.index(output_packed_pose)
    if isinstance(input_packed_pose, PackedPose):
        poses.append(input_packed_pose)
        metadata["idx_input"] = poses.index(input_packed_pose)
    signer = InitFileSigner(
        input_packed_pose=input_packed_pose,
        output_packed_pose=output_packed_pose,
        metadata=metadata,
    )
    metadata.update(signer.sign())

    return metadata, poses


def get_poses_from_init_file(
    init_file: str
) -> Tuple[Optional[PackedPose], Optional[PackedPose]]:
    """
    Return a `tuple` of the input `PackedPose` object and the 
    output `PackedPose` object from a '.init' file.
    """

    assert isinstance(init_file, str) and os.path.isfile(init_file), (
        "The input 'init_file' argument parameter must be a `str` object and exist on disk. "
        + f"Received: '{init_file}'"
    )
    with open(init_file, "r") as f:
        init_dict = json.load(
            f,
            cls=None,
            object_hook=None,
            parse_float=None,
            parse_int=None,
            parse_constant=None,
            object_pairs_hook=None,
        )
    for key in ("metadata", "poses"):
        assert key in init_dict.keys(), (
            f"The 'init_file' argument parameter does not contain the '{key}' key: '{init_file}'"
        )
    metadata = init_dict["metadata"]
    poses = init_dict["poses"]

    assert was_init_called(), (
        f"Please first initialize PyRosetta with the 'init_file' argument parameter: '{init_file}'"
    )
    input_packed_pose = io.to_packed(
        io.to_pose(poses[metadata["idx_input"]])
    ) if "idx_input" in metadata else None
    output_packed_pose = io.to_packed(
        io.to_pose(poses[metadata["idx_output"]])
    ) if "idx_output" in metadata else None

    return (input_packed_pose, output_packed_pose)

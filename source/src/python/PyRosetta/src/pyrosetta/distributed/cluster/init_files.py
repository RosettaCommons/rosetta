# :noTabs=true:
# (c) Copyright Rosetta Commons Member Institutions.
# (c) This file is part of the Rosetta software suite and is made available under license.
# (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
# (c) For more information, see http://www.rosettacommons.org. Questions about this can be
# (c) addressed to University of Washington CoMotion, email: license@uw.edu.


__author__ = "Jason C. Klima"


import json
import hmac
import os
import pyrosetta
import pyrosetta.distributed.io as io

from pyrosetta.distributed.packed_pose.core import PackedPose
from typing import Any, Dict, Generic, List, Optional, Tuple, TypeVar

from pyrosetta.distributed.cluster.hkdf import HASHMOD, compare_digest, derive_init_key


G = TypeVar("G")


class InitFileSigner(Generic[G]):
    """Sign PyRosetta initialization files by PyRosettaCluster."""

    _encoding = "utf-8"
    _prefix = b'PyRosettaCluster_init_file_signer'
    _secret = b'\xdc\xb2\xcc\x94\xab\xa0(\x89\xcdU\xdd\xaf\x80\x94-I\xa9\x1b%\xe1\xa4\xf7\xa1\x82M#\x02\x17\\\xffX3'

    def __init__(self, input_packed_pose=None, output_packed_pose=None) -> None:
        self.inp_pkl = self.to_pickle(input_packed_pose)
        self.out_pkl = self.to_pickle(output_packed_pose)

    def to_pickle(self, packed_pose: Optional[PackedPose]) -> bytes:
        return io.to_pickle(packed_pose) if isinstance(packed_pose, PackedPose) else b'\x00'

    def get_pose_digest(self, pkl: bytes) -> bytes:
        return HASHMOD(pkl).digest()

    def join_bytes(self, *values: List[bytes]) -> bytes:
        return b'+'.join(values)

    def setup_poses_pair(self, inp_pkl: bytes, out_pkl: bytes) -> bytes:
        return self.join_bytes(InitFileSigner._prefix, inp_pkl, out_pkl)

    def get_poses_digest(self, inp_pkl: bytes, out_pkl: bytes) -> bytes:
        return HASHMOD(self.setup_poses_pair(inp_pkl, out_pkl)).digest()

    def get_poses_hexdigest(self, inp_pkl: bytes, out_pkl: bytes) -> str:
        return HASHMOD(self.setup_poses_pair(inp_pkl, out_pkl)).hexdigest()

    def get_pkg_data(self, poses_digest: bytes) -> bytes:
        return self.join_bytes(
            InitFileSigner._prefix,
            pyrosetta._version_string().encode(InitFileSigner._encoding),
            pyrosetta.distributed.cluster.__version__.encode(InitFileSigner._encoding),
            poses_digest,
        )

    def get_hmac_hexdigest(self, key: bytes, data: bytes) -> str:
        return hmac.new(key, data, HASHMOD).hexdigest()

    def sign(self) -> Dict[str, str]:
        inp_digest = self.get_pose_digest(self.inp_pkl)
        out_digest = self.get_pose_digest(self.out_pkl)
        poses_digest = self.get_poses_digest(self.inp_pkl, self.out_pkl)
        pkg_data = self.get_pkg_data(poses_digest)
        key = derive_init_key(InitFileSigner._secret, pkg_data)
        msg = self.join_bytes(InitFileSigner._prefix, inp_digest, out_digest, pkg_data)

        return {
            "sha256": self.get_poses_hexdigest(self.inp_pkl, self.out_pkl),
            "signature": self.get_hmac_hexdigest(key, msg),
        }

    def verify(self, sha256: str, signature: str) -> bool:
        expected_sha256 = self.get_poses_hexdigest(self.inp_pkl, self.out_pkl)
        if sha256 != expected_sha256:
            return False
        inp_digest = self.get_pose_digest(self.inp_pkl)
        out_digest = self.get_pose_digest(self.out_pkl)
        poses_digest = self.get_poses_digest(self.inp_pkl, self.out_pkl)
        pkg_data = self.get_pkg_data(poses_digest)
        key = derive_init_key(InitFileSigner._secret, pkg_data)
        msg = self.join_bytes(InitFileSigner._prefix, inp_digest, out_digest, pkg_data)
        expected_signature = self.get_hmac_hexdigest(key, msg)

        return compare_digest(signature, expected_signature)


def setup_init_file_metadata_and_poses(
    input_packed_pose: Optional[PackedPose] = None,
    output_packed_pose: Optional[PackedPose] = None,
) -> Tuple[Dict[str, Any], List[PackedPose]]:
    """Setup PyRosetta initialization file 'metadata' and 'poses' keys."""

    metadata = {}
    metadata["comment"] = "Generated by PyRosettaCluster"
    metadata["version"] = pyrosetta.distributed.cluster.__version__
    poses = []
    if isinstance(output_packed_pose, PackedPose): # Set output decoy to front of poses list if present
        poses.append(output_packed_pose)
        metadata["idx_output"] = poses.index(output_packed_pose)
    if isinstance(input_packed_pose, PackedPose):
        poses.append(input_packed_pose)
        metadata["idx_input"] = poses.index(input_packed_pose)
    signer = InitFileSigner(
        input_packed_pose=input_packed_pose,
        output_packed_pose=output_packed_pose,
    )
    metadata.update(signer.sign())

    return metadata, poses


def get_poses_from_init_file(
    init_file: str
) -> Tuple[Optional[PackedPose], Optional[PackedPose]]:
    """
    Return a `tuple` of the input `PackedPose` object and the 
    output `PackedPose` object from a '.init' file.
    """

    assert isinstance(init_file, str) and os.path.isfile(init_file), (
        "The input 'init_file' argument parameter must be a `str` object and exist on disk. "
        + f"Received: '{init_file}'"
    )
    with open(init_file, "r") as f:
        init_dict = json.load(
            f,
            cls=None,
            object_hook=None,
            parse_float=None,
            parse_int=None,
            parse_constant=None,
            object_pairs_hook=None,
        )
    for key in ("metdata", "poses"):
        assert key in init_dict.keys(), (
            f"The 'init_file' argument parameter does not contain the '{key}' key: '{init_file}'"
        )
    metadata = init_dict["metadata"]
    poses = init_dict["poses"]
    input_packed_pose = io.to_packed(
        io.to_pose(poses[metadata["idx_input"]])
    ) if "idx_input" in metadata else None
    output_packed_pose = io.to_packed(
        io.to_pose(poses[metadata["idx_output"]])
    ) if "idx_output" in metadata else None

    return (input_packed_pose, output_packed_pose)

// vi: set ts=2 noet:
//
// (c) Copyright Rosetta Commons Member Institutions.
// (c) This file is part of the Rosetta software suite and is made available under license.
// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
// (C) 199x-2008 University of Washington
// (C) 199x-2008 University of California Santa Cruz
// (C) 199x-2008 University of California San Francisco
// (C) 199x-2008 Johns Hopkins University
// (C) 199x-2008 University of North Carolina, Chapel Hill
// (C) 199x-2008 Vanderbilt University

/*!

@page constraint_file Constraint File Instructions

@section metadata Metadata
This document was edited by Colin Smith on 12/4/2008. Yi Liu created the initial page. Thanks Oliver and Firas for providing information.

@section file_format File Formats

Constraints can be specified using two different file formats, line-based and section-based. The line-based format is:

@verbatim
Constraint_Type1 Constraint_Def1
Constraint_Type2 Constraint_Def2
...
@endverbatim

Generally speaking, the Constraint_Type will contain a type, defining what sort of value to be constrained (distance, angle, dihedral, etc), and a series of atom and/or residue labels defining a specific quality to be constrained.  Residue numbers are assumed to be in Rosetta numbering (from 1, no gaps), not PDB numbering.  If you want PDB numbering, pass the chain letter immediately after the residue number (no spaces), residue 30 of chain A would be "30A", even if it is the first residue in the PDB (Rosetta numbering "1").  

The Constraint_Def will define function by which the constraint is constrained, to answer the question: what should the score of the constraint be when the constrained value has a deviation of X units?

@section constraint_type Constraint Types

Constraint types are all implemented as subclasses of the core::scoring::constraints::Constraint class.

@subsection single_constraint_types Single constraints

Single constraints restrain the value of a single metric

@li @ref AtomPairConstraint "AtomPair":<br>
<tt>AtomPair Atom1_Name Atom1_ResNum Atom2_Name Atom2_ResNum Func_Type Func_Def</tt><br>
Constrains a distance between Atom1 and Atom2.  AtomPairConstraint is compatible with PDB numbering.

@li @ref AngleConstraint "Angle":<br>
<tt>Angle Atom1_Name Atom1_ResNum Atom2_Name Atom2_ResNum Atom3_Name Atom3_ResNum Func_Type Func_Def</tt><br>
Angle between Atom2->Atom1 vector and Atom2->Atom3 vector; the angle (passed as a value to the Func) appears to be measured in radians

@li @ref DihedralConstraint "Dihedral":<br>
<tt>Dihedral Atom1_Name Atom1_ResNum Atom2_Name Atom2_ResNum Atom3_Name Atom3_ResNum Atom4_Name Atom4_ResNum Func_Type Func_Def</tt><br>
Dihedral angle of Atom1->Atom2->Atom3->Atom4.  Dihedral is measured in radians on -pi -> pi.

@li @ref CoordinateConstraint "CoordinateConstraint":<br>
<tt>CoordinateConstraint Atom1_Name Atom1_ResNum Atom2_Name Atom2_ResNum Atom1_target_X_coordinate Atom1_target_Y_coordinate Atom1_target_Z_coordinate Func_Type Func_Def</tt><br>
Constrain Atom1 to the XYZ position listed.  Atom2 is used as a reference atom to determine when Atom1 has moved (so that Rosetta knows when to rescore it) - pick at atom that Atom1 will move relative to.  CoordinateConstraint is compatible with PDB numbering.

@li @ref LocalCoordinateConstraint "LocalCoordinateConstraint":<br>
<tt>LocalCoordinateConstraint Atom1_Name Atom1_ResNum Atom2_Name Atom3_Name Atom4_Name Atom234_ResNum Atom1_target_X_coordinate Atom1_target_Y_coordinate Atom1_target_Z_coordinate Func_Type Func_Def</tt><br>
Constrain Atom1 to the XYZ position listed, relative to the coordinate frame defined by atoms 2/3/4 instead of the origin.  LocalCoordinateConstraint is compatible with PDB numbering.

@li @ref AmbiguousNMRDistanceConstraint "AmbiguousNMRDistance":<br>
<tt>AmbiguousNMRDistance Atom1_Name Atom1_ResNum Atom2_Name Atom2_ResNum Func_Type Func_Def</tt><br>
Distance between Atom1 and Atom2.  The difference from AtomPairConstraint is that atom names are specially parsed to detect ambiguous hydrogens, which are either experimentally ambiguous or rotationally identical (like methyl hydrogens).  The constraint applies to any hydrogens equivalent to the named hydrogen.  The logic for determining which hydrogens are which is in src/core/scoring/constraints/AmbiguousNMRDistanceConstraints.cc:parse_NMR_name.

@li @ref SiteConstraint "SiteConstraint":<br>
<tt>SiteConstraint Atom1_Name Atom1_ResNum Opposing_chain Func_Type Func_Def</tt><br>
Constraint that a residue interacts with some other chain - roughly, that it is (or is not) in a binding site.  The atom and resnum identify which atom is being checked for interactions with the opposing chain.  Notice that "Constraint" is irregularly in its tag.

@li @ref BigBinConstraint "BigBin":<br>
<tt>BigBin ResNum Bin</tt>

@subsection nested_constraint_types Nested constraints

Nested constraints take as their parameters one or more other constraints, and allow optimization across multiple constraints. Typically in constraint files these are listed across multiple lines, with the name of the constraint opening the block of sub-constraints, and a line starting with "END" or "End" ending the block. 

@li @ref MultiConstraint "MultiConstraint":<br>
<tt>MultiConstraint<br>
Constraint_Type1 Constraint_Def1 <br>
[Constraint_Type2 Constraint_Def2 <br>
[...]]
END</tt><br>
Sum of all specified constraints

@li @ref AmbiguousConstraint "AmbiguousConstraint":<br>
<tt>AmbiguousConstraint<br>
Constraint_Type1 Constraint_Def1 <br>
[Constraint_Type2 Constraint_Def2 <br>
[...]]
END</tt><br>
Lowest of all specified constraints

@li @ref KofNConstraint "KofNConstraint":<br>
<tt>KofNConstraint k<br>
Constraint_Type1 Constraint_Def1 <br>
[Constraint_Type2 Constraint_Def2 <br>
[...]]
END</tt><br>
Value is the sum of the "k" lowest energy constraints

@section function_type Function Types

Functions are listed as "Func_Type: Func_Def".

@li @ref HarmonicFunc "HARMONIC":
<tt>x0 sd</tt>
@f[ 
f(x) = \left( \frac{x - x0}{sd} \right)^2 
@f]

@li @ref CircularHarmonicFunc "CIRCULARHARMONIC":
<tt>x0 sd</tt>
@f[ f(x) = \left( \frac{NearestAngleRadians(x, x0) - x0}{sd} \right)^2 @f]

@li @ref BoundFunc "BOUNDED":
<tt>lb ub sd rswitch tag</tt><br>
Note: Setting <tt>rswitch</tt> to anything other than 0.5 will create a discontinuity in the derivative.  <tt>rswitch</tt> and <tt>tag</tt> should not be treated as optional.
@f[
f(x) = \left \{
\begin{array}{rcl}
  \left( \frac{x - lb}{sd} \right)^2 & \mbox{for} & x < lb \\
  0 & \mbox{for} & lb \le x \le ub \\
  \left( \frac{x - ub}{sd} \right)^2 & \mbox{for} & ub < x \le ub + rswitch \cdot sd \\
  \frac{1}{sd} \left( x - \left( ub + rswitch \cdot sd \right) \right) + \left( \frac{rswitch \cdot sd}{sd} \right)^2 & \mbox{for} & x > ub + rswitch \cdot sd
\end{array} \right.
@f]

@li @ref GaussianFunc "GAUSSIANFUNC":
<tt>mean sd tag</tt>
Note: <tt>tag</tt> is NOT optional, as for BoundFunc/BOUNDED.  If <tt>tag</tt> = NOLOG, it triggers some undocumented behavior involving a logarithm of some sort.
@f[ f(x) = -\ln \left( \frac{1}{sd \sqrt{2\pi}} * \exp \left( -\frac{(x-mean)^2}{2 sd^2} \right) \right) @f]

@li @ref SOGFunc "SOGFUNC":
<tt>n_funcs [mean1 sdev1 weight1 [mean2 sdev2 weight2 [...]]]</tt>
@f[ f(x) = -\ln \left( \sum_{i=1}^{n\_funcs} weight_i * \frac{1}{sdev_i \sqrt{2\pi}} * \exp \left( -\frac{(x-mean_i)^2}{2 sdev_i^2} \right) \right) @f]

@li @ref MixtureFunc "MIXTUREFUNC":
<tt>anchor gaussian_param exp_param mixture_param bg_mean bg_sd</tt><br>
parameters: representing the mean of h(r), representing the standard deviation of h(r)

@li @ref ConstantFunc "CONSTANTFUNC":
<tt>return_val</tt>
@f[ f(x) = return\_val @f]

@li @ref ScalarWeightedFunc "SCALARWEIGHTEDFUNC":
<tt>weight Func_Type Func_Def</tt>
@f[ f(x) = weight*Func\_Type(x, Func\_Def) @f]

@li @ref SumFunc "SUMFUNC":
<tt>n_funcs Func_Type1 Func_Def1 [Func_Type2 Func_Def2 [...]]</tt>
@f[ f(x) = \sum_{i=1}^{n\_funcs} Func\_Type_i(x, Func\_Def_i) @f]

@li @ref SplineFunc "SPLINE":
<tt>histogram_file_path experimental_value weight bin_size</tt>
Note: This function reads in any histogram and creates a cubic spline over it using the Rosetta SplineGenerator.  The full path to the file must be speified.  The function assumes that all bin sizes are the same, even though you must specify it for each line in the cst file. If using RosettaEPR knowledge-based potential, replace <filename> with EPR_DISTANCE, and it will read in the EPR distance histogram from the minirosetta database. See example below for using with EPR knowledge-based potential.

@li @ref FadeFunc "FADE": <tt>lb ub d wd [ wo ] </tt><br>
This is meant to basically be a smoothed "square well" bonus of <tt>wd</tt> between the boundaries <tt>lb</tt> and <tt>ub</tt>. An optional offset <tt>wo</tt> (default 0) can be added to the whole function; this is useful if you want to make the function be zero in the 'golden range' and then give a penalty elsewhere (e.g., specify wd of -20 and wo of +20). To make sure the function and its derivative are continuous, the function is connected by cubic splines in the boundary regions in slivers of width d, between <tt>lb</tt> to <tt>lb+d</tt> and between <tt>ub-d</tt> to <tt>ub</tt>:
@f[
f(x) = \left \{
\begin{array}{rcl}
  wo & \mbox{for} & x < lb \\
  wo + wd * ( 2 b^3 - 3 b^2 + 1), \mbox{where }  b = - \frac{1}{d}\left[ x - (lb+d) \right] & \mbox{for} &  lb \le x < lb+d \\
  wo + wd & \mbox{for} & lb+d \le x < ub-d \\
  wo + wd * ( 2 b^3 - 3 b^2 + 1), \mbox{where }  b = \frac{1}{d} \left[ x - (ub-d) \right] & \mbox{for} &  ub - d \le x < lb \\
  wo & \mbox{for} & x \le ub \\
\end{array} \right.
@f]

@li @ref SigmoidFunc "SIGMOID": <tt> x0 m </tt>
Two arguments; x0 is the center of the sigmoid func and m is its slope.  It has hardcoded min/max of 0.5.  The functional form is (1/(1+exp(-m*( x-x0 ))) - 0.5.

Function types are all implemented as subclasses of the core::scoring::constraints::Func class.

@section samples Sample Files
@verbatim
AtomPair CZ 20 CA 6 GAUSSIANFUNC 5.54 2.0
AtomPair CZ 20 CA 54 GAUSSIANFUNC 5.27 2.0
AtomPair CZ 20 CA 50 GAUSSIANFUNC 5.26 2.0
AtomPair CZ 20 CA 10 GAUSSIANFUNC 4.81 2.0
AtomPair CZ 20 CA 41 GAUSSIANFUNC 9.90 2.0
@endverbatim

@verbatim
AtomPair SG 5 V1 32 HARMONIC 0.0 0.2
Angle CB 5 SG 5 ZN 32 HARMONIC 1.95 0.35
AtomPair SG 8 V2 32 HARMONIC 0.0 0.2
Angle CB 8 SG 8 ZN 32 HARMONIC 1.95 0.35
AtomPair NE2 13 V3 32 HARMONIC 0.0 0.2
Angle CD2 13 NE2 13 ZN 32 HARMONIC 2.09 0.35
Dihedral CG 13 CD2 13 NE2 13 ZN 32 CIRCULARHARMONIC 3.14 0.35
AtomPair SG 18 V4 32 HARMONIC 0.0 0.2
Angle CB 18 SG 18 ZN 32 HARMONIC 1.95 0.35
@endverbatim

@verbatim
#discourages residue 16, chain B, from interacting with chain A; encourages residue 47
SiteConstraint CA 16B A SIGMOID 5.0 -2.0
SiteConstraint CA 47B A SIGMOID 5.0 2.0
@endverbatim

@verbatim
AtomPair H  6 HA 134 BOUNDED  1.80 5.25 0.50 NOE ;dist 5.000 1.800
AtomPair HA 7 HA 132 HARMONIC 1.2 0.2
@endverbatim

@verbatim
AtomPair CB 31 CB 43 SPLINE EPR_DISTANCE  6.0 4.0 0.5
AtomPair CB 29 CB 62 SPLINE EPR_DISTANCE 15.0 4.0 0.5
@endverbatim

@section code Code for Reading Constraints

There are different sets of functions for reading full-atom and non-full-atom constraints, as indicated by the respective functions listed below. The only current difference between the functions are which command line arguments are read. The values of the arguments are processed identically.

To use constraints, both the scoring function and pose objects should be updated. The functions for adding constraints to the scoring function are:

@li core::scoring::constraints::add_fa_constraints_from_cmdline_to_scorefxn()
@li core::scoring::constraints::add_constraints_from_cmdline_to_scorefxn()

Currently these functions only set the weights of the atom_pair_constraint, angle_constraint, and dihedral_constraint score function terms to the value of either the -constraints:cst_fa_weight or -constraints:cst_weight command line argument.

The functions for adding constraints to the pose object are:

@li core::scoring::constraints::add_fa_constraints_from_cmdline_to_pose()
@li core::scoring::constraints::add_constraints_from_cmdline_to_pose()

These functons read a random constraint file from the list defined by either the  -constraints:cst_fa_file or -constraints:cst_file argument.

There are also convenience functions for doing both at once:

@li core::scoring::constraints::add_fa_constraints_from_cmdline()
@li core::scoring::constraints::add_constraints_from_cmdline()

@section other_constraint_type Other Constraint Types

These constraint types cannot currently be specified in a file. They need to have read_def methods implemented and be added to the ConstraintFactory constructor.

@li @ref BackboneStubConstraint "BackboneStub"
@li @ref ConstantConstraint "Constant"
@li @ref ResidueTypeConstraint "ResidueType"
@li @ref RotamerConstraint "Rotamer"

@section other_function_type Other Function Types

These function types cannot currently be specified in a file. They need to have read_data methods implemented and be added to the FuncFactory constructor.

@li @ref PeriodicBoundFunc "PeriodicBound"
@li @ref ChainbreakDistFunc "ChainbreakDist"
@li @ref CharmmPeriodicFunc "CharmmPeriodic"
@li @ref CircularPowerFunc "CircularPower"
@li @ref EtableFunc "Etable"
@li @ref CB_Angle_Func "CB_Angle"
@li @ref CBSG_Dihedral_Func "CBSG_Dihedral"
@li @ref SG_Dist_Func "SG_Dist"
@li @ref SGSG_Dihedral_Func "SGSG_Dihedral"
@li @ref LK_SigmoidalFunc "LK_Sigmoidal"

*/
